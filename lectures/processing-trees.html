<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>Class Summary: Processing Trees</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="scribble-style.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9658;</a></td><td></td><td><a href="" class="tocviewselflink" data-pltdoc="x">Class Summary:<span class="mywbr"> &nbsp;</span> Processing Trees</a></td></tr></table></div><div class="tocviewsublistonly" style="display: none;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="#%28part._.A_datatype_for_.Ancestor_.Trees%29" class="tocviewlink" data-pltdoc="x">A datatype for Ancestor Trees</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="#%28part._.Programs_to_.Process_.Ancestor_.Trees%29" class="tocviewlink" data-pltdoc="x">Programs to Process Ancestor Trees</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="#%28part._.Summarizing_.How_to_.Approach_.Tree_.Problems%29" class="tocviewlink" data-pltdoc="x">Summarizing How to Approach Tree Problems</a></td></tr></table></div></div></div><div class="tocsub"><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber"></span><a href="#%28part._.Class_.Summary__.Processing_.Trees%29" class="tocsubseclink" data-pltdoc="x">Class Summary:<span class="mywbr"> &nbsp;</span> Processing Trees</a></td></tr><tr><td><span class="tocsublinknumber">1<tt>&nbsp;</tt></span><a href="#%28part._.A_datatype_for_.Ancestor_.Trees%29" class="tocsubseclink" data-pltdoc="x">A datatype for Ancestor Trees</a></td></tr><tr><td><span class="tocsublinknumber">2<tt>&nbsp;</tt></span><a href="#%28part._.Programs_to_.Process_.Ancestor_.Trees%29" class="tocsubseclink" data-pltdoc="x">Programs to Process Ancestor Trees</a></td></tr><tr><td><span class="tocsublinknumber">3<tt>&nbsp;</tt></span><a href="#%28part._.Summarizing_.How_to_.Approach_.Tree_.Problems%29" class="tocsubseclink" data-pltdoc="x">Summarizing How to Approach Tree Problems</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><h2><a name="(part._.Class_.Summary__.Processing_.Trees)"></a>Class Summary: Processing Trees</h2><p>Copyright (c) 2017 Kathi Fisler</p><p>In the previous lecture, we talked about how tables are a poor choice
for capturing ancestor trees.  Each person must reference two people
(its biological parents). In a table, we can only capture references
by names, which we then must look up by searching the rows of the
table. But if we make our own data, we might be able to capture those
connections explicitly.</p><p>Here again is the sample ancestor tree that we were trying to capture:</p><p><img src="famtree.png" alt="" width="313" height="244"/></p><p>For simplicity, let&rsquo;s capture just the connections between people (as
shown in the diagram), and their eye colors, dropping the birth year
from the original example.</p><h3>1<tt>&nbsp;</tt><a name="(part._.A_datatype_for_.Ancestor_.Trees)"></a>A datatype for Ancestor Trees</h3><p>What might such a datatype look like? We at least need a constructor
for a person, with info on name, eye color, and parents:</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">data AncTree:</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">| person(</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">name :: String,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">eye :: String,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">mother :: ________,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">father :: ________ )</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">end</span></p></td></tr></table></p><p>The question is what type to use for the <span class="stt">mother</span> and
<span class="stt">father</span>. We could use <span class="stt">string</span> and list the names, but
that&rsquo;s back to what we had with the table (when we&rsquo;d have to look up
the people that go with the names). Instead, we want to put a whole
person in that spot of the tree. We can&rsquo;t write <span class="stt">person</span> because
that isn&rsquo;t a type name, but we can write <span class="stt">AncTree</span>.</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">data AncTree:</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">| person(</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">name :: String,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">eye :: String,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">mother :: AncTree,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">father :: AncTree )</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">end</span></p></td></tr></table></p><p>Now, let&rsquo;s try building the portion of the tree for John. It would
look something like:</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">person("John", "brown",</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">______,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">person("Robert", "green", _____, ______))</span></p></td></tr></table></p><p>We have to figure out what goes in the blanks, which correspond to
places where we don&rsquo;t have information about those people.</p><p>Should we use <span class="stt">empty</span>? While that&rsquo;s the right spirit, it doesn&rsquo;t
work in practice because <span class="stt">empty</span> is a list and our definition
says that we need to put an <span class="stt">AncTree</span> there.</p><p>Instead, we create a second kind of <span class="stt">AncTree</span> that corresponds to
people for whom we have no information:</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">data AncTree:</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">| person(</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">name :: String,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">eye :: String,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">mother :: AncTree,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">father :: AncTree )</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">| unknown</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">end</span></p></td></tr></table></p><p>The <span class="stt">unknown</span> option here provides a datum that is an
<span class="stt">AncTree</span>, but one for which we have no details (since there are
no fields/components to those data).</p><p>With that, we can finish the definition for John&rsquo;s portion of the
tree.</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">person("John", "brown",</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">unknown,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">person("Robert", "green", unknown, unknown))</span></p></td></tr></table></p><p>If we wanted to capture our entire ancestor tree diagram, we could
write it as following (using two examples for purposes of illustration
&ndash; there is no particular reason why we called out John&rsquo;s part of the
tree here):</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"># two examples of trees</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">johnT =</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">person("John", "brown",</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">unknown,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">person("Robert", "green", unknown, unknown))</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">annaT =</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">person(</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">"Anna", "blue",</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">person(</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">"Susan", "blue",</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">person("Ellen", "brown",</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">person("Laura", "blue", unknown, unknown),</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">johnT),</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">unknown), # note we use johnT here to build annaT</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">person("Charlie", "green", unknown, unknown))</span></p></td></tr></table></p><h3>2<tt>&nbsp;</tt><a name="(part._.Programs_to_.Process_.Ancestor_.Trees)"></a>Programs to Process Ancestor Trees</h3><p>How would we write a function to determine whether anyone in the tree
had a particular name? To be clear, we are trying to fill in the
following code:</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">fun in-tree(name :: String, anct :: AncTree) -&gt; Boolean:</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">doc: "does given name appear in the tree"</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">...</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">where:</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">in-tree("Robert", johnT) is true</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">in-tree("Kathi", johnT) is false</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">in-tree("John", unknown) is false</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">end</span></p></td></tr></table></p><p>How do we get started?  When we were working on lists, we talked about
the <span style="font-style: italic">template</span>, a skeleton of code that we knew we could write
based on the structure of the data. The template names the pieces of
each kind of data, and makes recursive calls on pieces that have the
same type.  Here&rsquo;s the template over the <span class="stt">AncTree</span> filled in:</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">fun in-tree(name :: String, anct :: AncTree) -&gt; Boolean:</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">doc: "does given name appear in the tree"</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">cases (AncTree) anct:</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">| unknown =&gt; ...</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">| person(nm, eye, mo, fa) =&gt;</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">... in-tree(name, mo) ... in-tree(name, fa)</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">end</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">where:</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">in-tree("Robert", johnT) is true</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">in-tree("Kathi", johnT) is false</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">in-tree("John", unknown) is false</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">end</span></p></td></tr></table></p><p>To finish the code, we need to think about how to fill in the
ellipses.</p><ul><li><p>When the tree is <span class="stt">unknown</span>, it has no more people, so the answer
should be false.</p></li><li><p>When the tree is a person, there are three possibilities: we
could be at a person with the name we&rsquo;re looking for, or the name
could be in the mother&rsquo;s tree, or the name could be in the father&rsquo;s
tree.</p><p>We know how to check whether the person&rsquo;s name matches the one
we are looking for. The recursive calls already ask about the name
being in the mother&rsquo;s tree or father&rsquo;s tree.  We just need to combine
those pieces into one Boolean answer. Since there are three
possibilities, we should combine them with <span class="stt">or</span></p></li></ul><p>Here&rsquo;s the final code:</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">fun in-tree(name :: String, anct :: AncTree) -&gt; Boolean:</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">doc: "does given name appear in the tree"</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">cases (AncTree) anct:</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">| unknown =&gt; false</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">| person(nm, eye, mo, fa) =&gt;</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">(nm == name) or in-tree(name, mo) or in-tree(name, fa)</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">end</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">where:</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">in-tree("Robert", johnT) is true</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">in-tree("Kathi", johnT) is false</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">in-tree("John", unknown) is false</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">end</span></p></td></tr></table></p><h3>3<tt>&nbsp;</tt><a name="(part._.Summarizing_.How_to_.Approach_.Tree_.Problems)"></a>Summarizing How to Approach Tree Problems</h3><p>We design tree programs using the same design recipe that we covered
two weeks ago (Oct 17th in 2018):</p><ul><li><p>Write the datatype for your tree, including a base/leaf case</p></li><li><p>Write examples of your trees for use in testing</p></li><li><p>Write the function name, parameters, and types (the <span class="stt">fun</span>
line)</p></li><li><p>Write <span class="stt">where</span> checks for your code</p></li><li><p>Write the template, including the cases and recursive
calls. Here&rsquo;s the template again for an ancestor tree, for an
arbitrary function called treeF:</p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">fun treeF(name :: String, t :: AncTree) -&gt; Boolean:</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">cases (AncTree) anct:</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">| unknown =&gt; ...</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">| person(nm, eye, mo, fa) =&gt;</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">... treeF(name, mo) ... treeF(name, fa)</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">end</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">end</span></p></td></tr></table></li><li><p>Fill in the template with details specific to the problem</p></li><li><p>Test your code using your examples</p></li></ul><p>For practice, try problems such as</p><ul><li><p>How many blue-eyed people are in the tree?</p></li><li><p>How many people are in the tree?</p></li><li><p>How many generations are in the tree?</p></li><li><p>How many people have a given name in a tree?</p></li><li><p>How many people have names starting with "A"?</p></li><li><p>... and so on</p></li></ul></div></div><div id="contextindicator">&nbsp;</div></body></html>