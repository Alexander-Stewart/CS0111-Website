<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>Class summary: Datatypes, Efficiency, and Ancestor Trees</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="scribble-style.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9658;</a></td><td></td><td><a href="" class="tocviewselflink" data-pltdoc="x">Class summary:<span class="mywbr"> &nbsp;</span> Datatypes, Efficiency, and Ancestor Trees</a></td></tr></table></div><div class="tocviewsublistonly" style="display: none;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="#%28part._.Organizing_.Game_.States%29" class="tocviewlink" data-pltdoc="x">Organizing Game States</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="#%28part._.Efficiency_of_.Merging_.Tables%29" class="tocviewlink" data-pltdoc="x">Efficiency of Merging Tables</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="#%28part._.Data_.Design_.Problem_--_.Ancestry_.Data%29" class="tocviewlink" data-pltdoc="x">Data Design Problem &ndash; Ancestry Data</a></td></tr></table></div></div></div><div class="tocsub"><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber"></span><a href="#%28part._.Class_summary__.Datatypes__.Efficiency__and_.Ancestor_.Trees%29" class="tocsubseclink" data-pltdoc="x">Class summary:<span class="mywbr"> &nbsp;</span> Datatypes, Efficiency, and Ancestor Trees</a></td></tr><tr><td><span class="tocsublinknumber">1<tt>&nbsp;</tt></span><a href="#%28part._.Organizing_.Game_.States%29" class="tocsubseclink" data-pltdoc="x">Organizing Game States</a></td></tr><tr><td><span class="tocsublinknumber">2<tt>&nbsp;</tt></span><a href="#%28part._.Efficiency_of_.Merging_.Tables%29" class="tocsubseclink" data-pltdoc="x">Efficiency of Merging Tables</a></td></tr><tr><td><span class="tocsublinknumber">3<tt>&nbsp;</tt></span><a href="#%28part._.Data_.Design_.Problem_--_.Ancestry_.Data%29" class="tocsubseclink" data-pltdoc="x">Data Design Problem &ndash; Ancestry Data</a></td></tr><tr><td><span class="tocsublinknumber">3.1<tt>&nbsp;</tt></span><a href="#%28part._.Ancestry_.Trees_as_.Tables%29" class="tocsubseclink" data-pltdoc="x">Ancestry Trees as Tables</a></td></tr><tr><td><span class="tocsublinknumber">3.2<tt>&nbsp;</tt></span><a href="#%28part._.Creating_a_.Datatype_for_.Ancestor_.Trees%29" class="tocsubseclink" data-pltdoc="x">Creating a Datatype for Ancestor Trees</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><h2><a name="(part._.Class_summary__.Datatypes__.Efficiency__and_.Ancestor_.Trees)"></a>Class summary: Datatypes, Efficiency, and Ancestor Trees</h2><p>Copyright (c) 2017 Kathi Fisler</p><h3>1<tt>&nbsp;</tt><a name="(part._.Organizing_.Game_.States)"></a>Organizing Game States</h3><p>We reviewed the use of multi-case datatypes and how they might relate
to defining the state of a videogame.  Imagine that you were building
a game that featured a robot and an alien. Which of the following two
datatypes makes more sense?</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">data GameState1:</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">| robot(pos :: Posn)</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">| alien(pos :: Posn)</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">end</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">data GameState2:</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">| state(robot-pos :: Posn, alien-pos :: Posn)</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">end</span></p></td></tr></table></p><p>Briefly, the first has you choose between the robot or the alien,
whereas the second has both a robot and a alien in the game. See the
lecture capture for more discussion of this.</p><h3>2<tt>&nbsp;</tt><a name="(part._.Efficiency_of_.Merging_.Tables)"></a>Efficiency of Merging Tables</h3><p>We reviewed the terminology of <span style="font-style: italic">constant</span>, <span style="font-style: italic">linear</span>, and
<span class="stt">quadratic</span> when talking about efficiency, including presenting a
diagram showing what each of these look like as graphs of the size of
an input versus the number of underlying computations that get
performed.</p><p>We then returned to the table merging example from the first project,
to contrast the efficiency of the approach you took in the project
from an approach based on treating the columns as lists.  The
punchline here is that how to represent your data has a big impact on
how efficiently a computation can be performed.</p><p>See the lecture capture for more detail.</p><h3>3<tt>&nbsp;</tt><a name="(part._.Data_.Design_.Problem_--_.Ancestry_.Data)"></a>Data Design Problem &ndash; Ancestry Data</h3><p>Imagine that we wanted to represent geneaology information for
purposes of a medical research study. Specifically, we want to record
people&rsquo;s birthyear, eye colors, and biological parents. Here&rsquo;s a
picture showing the relationships between people and their biological
parents.</p><p><img src="famtree.png" alt="" width="313" height="244"/></p><p>To capture this in code, we might create a table such as the following:</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">family = table: name, birthyear, eyecolor, mother, father</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">row: "Anna", 1997, "blue", "Susan", "Charlie"</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">row: "Susan", 1971, "blue", "Ellen", "Bill"</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">row: "Charlie" 1972, "green", "NoInfo", "NoInfo"</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">row: "Ellen", 1945, "brown", "Laura", "John"</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">...</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">end</span></p></td></tr></table></p><p>Assume we wanted to be able to answer questions such as the following:</p><ul><li><p>How frequent is each eye color?</p></li><li><p>How many generations do we have information for?</p></li><li><p>What&rsquo;s the average age of mothers (or fathers) at time of birth?</p></li><li><p>Is one specific person an ancestor of another specific person?</p></li></ul><p>How should we capture this picture in data to be able to write
programs to answer our questions?</p><h4>3.1<tt>&nbsp;</tt><a name="(part._.Ancestry_.Trees_as_.Tables)"></a>Ancestry Trees as Tables</h4><p><span style="font-style: italic">These notes have more detail than we did in class. In class we
talked through the problem of finding ancestors loosely. Here, the
underlying code is presented in more detail.</span></p><p>Let&rsquo;s say I wanted to write a function to compute someone&rsquo;s
grandparents (at least, those grandparents known in the tree)</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">fun grandparents(of-name :: String) -&gt; List&lt;String&gt;:</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">...</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">where:</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">grandparents("Anna") is [list: "Laura", "John"]</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">grandparents("Laura") is [list:]</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">grandparents("Kathi") is [list:]</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">end</span></p></td></tr></table></p><p>What would be involved in doing that computation? What subtasks would
we identify/what functions would we write?</p><ul><li><p>Need to go from a name to the mother</p></li><li><p>Need to go from a name to the father</p></li><li><p>Repeat previous two steps on mother and father</p></li></ul><p>Let&rsquo;s write one of these functions to see what it would look like:</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">import lists as L</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">fun get-mother(of-name :: String, from-table :: Table):</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">person-row =</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">filter-by(from-table,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">lam(r :: Row): r["name"] == of-name end).row-n(0)</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">person-row["mother"]</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">where:</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">get-mother("Anna", family) is "Susan"</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">end</span></p></td></tr></table></p><p>What happens if the person we asked for isn&rsquo;t in the table
(meaning that we don&rsquo;t know their family history)?  Right now,
we get a Pyret error.  The error arises because we shouldn&rsquo;t
try to use <span class="stt">L.get</span> unless we know that we found a row for the
named person.  We could modify the code, but that would be premature.</p><p>As always, start with examples: what should the function produce
if the named person doesn&rsquo;t have a row in the table?</p><ul><li><p>if we raise an error, we can&rsquo;t use this function to get whichever
grandparents are known (the raise would terminate the function)</p></li><li><p>if we use something like "unknown", we can&rsquo;t tell the difference
between a real name and this value (both are strings)</p></li><li><p>in practice, we want to return an answer of a _different type_,
to avoid both problems.  Here, we could return false (the boolean)
to indicate that the person wasn&rsquo;t found.</p></li></ul><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">fun get-mother2(of-name :: String, from-table :: Table):</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">person-table =</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">filter-by(from-table, lam(r :: Row): r["name"] == of-name end)</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">if person-table.length() &gt; 0:</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">person-table.row-n(0)["mother"]</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">else:</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">false</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">end</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">where:</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">get-mother2("Anna", family) is "Susan"</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">get-mother2("Fred", family) is false</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">end</span></p></td></tr></table></p><p>If you imagine chaining together calls to <span class="stt">get-mother</span> in order
to find ancestors (and having to also do that on the father&rsquo;s side),
we&rsquo;d quickly see that we end up doing a lot of table filtering, which
seems inefficient.</p><p>Look back at the ancestry tree picture.  We don&rsquo;t do any complicated
filtering there &ndash; we just follow the line in the picture immediately
from a person to their mother or father.  Can we get that idea in code
instead? Yes, through datatypes.</p><h4>3.2<tt>&nbsp;</tt><a name="(part._.Creating_a_.Datatype_for_.Ancestor_.Trees)"></a>Creating a Datatype for Ancestor Trees</h4><p>For this approach, we want to create a datatype for Ancestor Trees
that has a variant (constructor) for setting up a person. Look
back at our picture &ndash; what information makes up a person? Their
name, their mother, and their father (along with birthyear and
eyecolor, which aren&rsquo;t shown in the picture).  This suggests the following
datatype, which basically turns a row into a person value:</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">data AncTree:</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">| person(</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">name :: String,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">birthyear :: Number,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">eye :: String,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">mother :: ________,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">father :: ________</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">)</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">end</span></p></td></tr></table></p><p>What type do we put in the blanks?  We did a quick brainstorm after
class, and came up with several ideas:
<span class="stt">person</span>. <span class="stt">List&lt;person&gt;</span>, some new datatype, <span class="stt">AncTree</span>,
<span class="stt">String</span> &ndash; which should it be??</p><p>Tune in next class ...</p></div></div><div id="contextindicator">&nbsp;</div></body></html>