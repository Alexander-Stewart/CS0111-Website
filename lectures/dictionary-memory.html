<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>Class summary: Memory and the Dictonary</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="notes.css" title="default"/><link rel="stylesheet" type="text/css" href="scribble-style.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9658;</a></td><td></td><td><a href="" class="tocviewselflink" data-pltdoc="x">Class summary:<span class="mywbr"> &nbsp;</span> Memory and the Dictonary</a></td></tr></table></div><div class="tocviewsublistonly" style="display: none;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="#%28part._.Introducing_.Memory%29" class="tocviewlink" data-pltdoc="x">Introducing Memory</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="#%28part._.Updating_.Memory_and_the_.Dictionary%29" class="tocviewlink" data-pltdoc="x">Updating Memory and the Dictionary</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="#%28part._.What_.About_.Atomic_.Values__like_.Nums_and_.Bools_%29" class="tocviewlink" data-pltdoc="x">What About Atomic Values, like Nums and Bools?</a></td></tr><tr><td align="right">4&nbsp;</td><td><a href="#%28part._.Summary__.The_.Update_.Rules%29" class="tocviewlink" data-pltdoc="x">Summary:<span class="mywbr"> &nbsp;</span> The Update Rules</a></td></tr></table></div></div></div><div class="tocsub"><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber"></span><a href="#%28part._.Class_summary__.Memory_and_the_.Dictonary%29" class="tocsubseclink" data-pltdoc="x">Class summary:<span class="mywbr"> &nbsp;</span> Memory and the Dictonary</a></td></tr><tr><td><span class="tocsublinknumber">1<tt>&nbsp;</tt></span><a href="#%28part._.Introducing_.Memory%29" class="tocsubseclink" data-pltdoc="x">Introducing Memory</a></td></tr><tr><td><span class="tocsublinknumber">2<tt>&nbsp;</tt></span><a href="#%28part._.Updating_.Memory_and_the_.Dictionary%29" class="tocsubseclink" data-pltdoc="x">Updating Memory and the Dictionary</a></td></tr><tr><td><span class="tocsublinknumber">3<tt>&nbsp;</tt></span><a href="#%28part._.What_.About_.Atomic_.Values__like_.Nums_and_.Bools_%29" class="tocsubseclink" data-pltdoc="x">What About Atomic Values, like Nums and Bools?</a></td></tr><tr><td><span class="tocsublinknumber">3.1<tt>&nbsp;</tt></span><a href="#%28part._.Updating_.Values_of_.Names_that_.Map_to_.Atomics%29" class="tocsubseclink" data-pltdoc="x">Updating Values of Names that Map to Atomics</a></td></tr><tr><td><span class="tocsublinknumber">3.2<tt>&nbsp;</tt></span><a href="#%28part._.Wait_--_.So_.Names_.Don_t_.Track_.Each_.Other___%29" class="tocsubseclink" data-pltdoc="x">Wait &ndash; So Names Don&rsquo;t Track Each Other???</a></td></tr><tr><td><span class="tocsublinknumber">4<tt>&nbsp;</tt></span><a href="#%28part._.Summary__.The_.Update_.Rules%29" class="tocsubseclink" data-pltdoc="x">Summary:<span class="mywbr"> &nbsp;</span> The Update Rules</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><h2><a name="(part._.Class_summary__.Memory_and_the_.Dictonary)"></a>Class summary: Memory and the Dictonary</h2><p>Copyright (c) 2017 Kathi Fisler</p><p>Last class, we looked at the following sequence of program operations,
and how subsequent changes to the contents of the ToDoItems were were
visible through the different names.</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">call1 = ToDoItem("call fred", date(2018, 11, 15), ["urgent"])</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">call2 = ToDoItem("call fred", date(2018, 11, 15), ["urgent"])</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">call3 = call1</span></p></td></tr></table></p><p>We discussed how modifying a field of either <span class="stt">call1</span> or
<span class="stt">call3</span> would be visible through the other, while modifications
to fields of <span class="stt">call2</span> aren&rsquo;t visible to either <span class="stt">call1</span> or
<span class="stt">call3</span>. We said there was a relationship between <span class="stt">call1</span> or
<span class="stt">call3</span> that isn&rsquo;t visible in a dictionary such as the following:</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">call1 --&gt; ToDoItem("call fred", date(2018, 11, 15), ["urgent"])</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">call2 --&gt; ToDoItem("call fred", date(2018, 11, 15), ["urgent"])</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">call3 --&gt; ToDoItem("call fred", date(2018, 11, 15), ["urgent"])</span></p></td></tr></table></p><p>This suggests that maybe our dictionary needs additional information.</p><h3>1<tt>&nbsp;</tt><a name="(part._.Introducing_.Memory)"></a>Introducing Memory</h3><p>Every time you use a constructor to create data, the new data gets
stored in a part of your computer called <span style="font-style: italic">memory</span>. Memory is a
mapping from locations (or addresses) to values. Just as a street
address refers to a specific building, a memory address refers to a
specific piece of data.</p><p>In our example above, <span class="stt">call1</span> and <span class="stt">call3</span> are referring to
the same location in memory, whereas <span class="stt">call2</span> refers to similar
data in a different location in memory (sort of like identical twins
living at different addresses, though there is no analog for
<span class="stt">call1</span> and <span class="stt">call3</span> with this metaphor).</p><p>So to really understand how updating variables and fields affects your
program, you have to track two pieces of information: memory, which
indicates which pieces of data you have, and the dictionary, which
indicates which data value each name refers to. For compound data
(like ToDoItems), we represent data values by their locations in
memory.</p><p>Returning to our original code fragment (plus a different ToDoItem for
illustration), here&rsquo;s how memory and the dictionary appear.</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">milk = ToDoItem("buy milk", date(2018, 11, 15), ["shopping"])</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">call1 = ToDoItem("call fred", date(2018, 11, 15), ["urgent"])</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">call2 = ToDoItem("call fred", date(2018, 11, 15), ["urgent"])</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">call3 = call1</span></p></td></tr></table></p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">Dictionary</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">Memory</span></p></td></tr><tr><td><p><span class="stt">-------------------------------------------------------------------</span></p></td></tr><tr><td><p><span class="stt">milk</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">--&gt; (loc 1000)</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">(loc 1000) --&gt; ToDoItem("buy milk" ...)</span></p></td></tr><tr><td><p><span class="stt">call1 --&gt; (loc 1001)</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">(loc 1001) --&gt; ToDoItem("call Fred" ...)</span></p></td></tr><tr><td><p><span class="stt">call2 --&gt; (loc 1002)</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">(loc 1002) --&gt; ToDoItem("call Fred" ...)</span></p></td></tr><tr><td><p><span class="stt">call3 --&gt; (loc 1001)</span></p></td></tr></table></p><p>The dictionary maps each name to the location where its data is
stored. Memory maps locations to values. <span class="stt">call1</span> and <span class="stt">call3</span>
refer to the same memory location (the <span class="stt">is</span> relationship in
Python), but <span class="stt">call2</span> refers to a different location.</p><p>[Note that the initial address 1000 is arbitrary &ndash; you can start from any
address number. By convention, I use four digit numbers so we don&rsquo;t
get confused with smaller numeric data (like 0, 4, 12) that we often
refer to in our programs.]</p><h3>2<tt>&nbsp;</tt><a name="(part._.Updating_.Memory_and_the_.Dictionary)"></a>Updating Memory and the Dictionary</h3><p>So what happens if we write something like</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">call3.descr = "call Tina"</span></p></td></tr></table></p><p>Python finds <span class="stt">call3</span> in the dictionary, then hops over to memory
to find the <span class="stt">descr</span> part of the data. Within memory, it changes
the description. So now our diagram looks like:</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">Dictionary</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">Memory</span></p></td></tr><tr><td><p><span class="stt">-------------------------------------------------------------------</span></p></td></tr><tr><td><p><span class="stt">milk</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">--&gt; (loc 1000)</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">(loc 1000) --&gt; ToDoItem("buy milk" ...)</span></p></td></tr><tr><td><p><span class="stt">call1 --&gt; (loc 1001)</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">(loc 1001) --&gt; ToDoItem("call Tina" ...)</span></p></td></tr><tr><td><p><span class="stt">call2 --&gt; (loc 1002)</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">(loc 1002) --&gt; ToDoItem("call Fred" ...)</span></p></td></tr><tr><td><p><span class="stt">call3 --&gt; (loc 1001)</span></p></td></tr></table></p><p>Following the arrows from <span class="stt">call1</span> into memory, you can see how
the change is visible to <span class="stt">call1</span> as well as <span class="stt">call3</span>.</p><h3>3<tt>&nbsp;</tt><a name="(part._.What_.About_.Atomic_.Values__like_.Nums_and_.Bools_)"></a>What About Atomic Values, like Nums and Bools?</h3><p>What if we also had names mapping to simple numbers, strings, or
bools?  Do they look the same across the dictionary and memory?</p><p>Not exactly. Simple data (called <span style="font-style: italic">atomic data</span>) just lives in the
dictionary. For example, assume our original program also included the
following two lines:</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">x = 4</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">y = 5</span></p></td></tr></table></p><p>Then our dictionary/memory diagram would appear as follows:</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">Dictionary</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">Memory</span></p></td></tr><tr><td><p><span class="stt">-------------------------------------------------------------------</span></p></td></tr><tr><td><p><span class="stt">milk</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">--&gt; (loc 1000)</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">(loc 1000) --&gt; ToDoItem("buy milk" ...)</span></p></td></tr><tr><td><p><span class="stt">call1 --&gt; (loc 1001)</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">(loc 1001) --&gt; ToDoItem("call Tina" ...)</span></p></td></tr><tr><td><p><span class="stt">call2 --&gt; (loc 1002)</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">(loc 1002) --&gt; ToDoItem("call Fred" ...)</span></p></td></tr><tr><td><p><span class="stt">call3 --&gt; (loc 1001)</span></p></td></tr><tr><td><p><span class="stt">x</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">--&gt; 4</span></p></td></tr><tr><td><p><span class="stt">y</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">--&gt; 5</span></p></td></tr></table></p><p>Wait &ndash; why do atomics live in the dictionary rather than in memory?
It&rsquo;s partly a question of space consumption. Compound data has
multiple fields, and hence needs multiple "spaces" in memory (one for
each field). Atomic data only needs one "space". It&rsquo;s also partly a
question of what you can do to data: we can&rsquo;t change the number 4 into
the number 5 (4 will always be 4), whereas we can change the contents
of fields in compound data. So since atomics only need one space and
can&rsquo;t be changed anyway, we leave them in the dictionary.</p><h4>3.1<tt>&nbsp;</tt><a name="(part._.Updating_.Values_of_.Names_that_.Map_to_.Atomics)"></a>Updating Values of Names that Map to Atomics</h4><p>So what if we now execute the line</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">x = y</span></p></td></tr></table></p><p>Python looks up the value for <span class="stt">y</span> in the dictionary, and updates
the value for <span class="stt">x</span> to match:</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">Dictionary</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">Memory</span></p></td></tr><tr><td><p><span class="stt">-------------------------------------------------------------------</span></p></td></tr><tr><td><p><span class="stt">milk</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">--&gt; (loc 1000)</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">(loc 1000) --&gt; ToDoItem("buy milk" ...)</span></p></td></tr><tr><td><p><span class="stt">call1 --&gt; (loc 1001)</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">(loc 1001) --&gt; ToDoItem("call Tina" ...)</span></p></td></tr><tr><td><p><span class="stt">call2 --&gt; (loc 1002)</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">(loc 1002) --&gt; ToDoItem("call Fred" ...)</span></p></td></tr><tr><td><p><span class="stt">call3 --&gt; (loc 1001)</span></p></td></tr><tr><td><p><span class="stt">x</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">--&gt; 5</span></p></td></tr><tr><td><p><span class="stt">y</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">--&gt; 5</span></p></td></tr></table></p><p>Note that this is exactly the same thing that happened when we ran
<span class="stt">call3 = call1</span> earlier: Python looked up the value for
<span class="stt">call1</span> in the dictionary and mapped <span class="stt">call3</span> to it. In that
case, the dictionary value for <span class="stt">call3</span> became a reference to a
memory location, but it was the same operation from the standpoint of
the dictionary.</p><p>So if we now change <span class="stt">x</span> again, will <span class="stt">y</span> also change?  For
example, what if we wrote</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">x = 12</span></p></td></tr></table></p><p>Follow our rule: the new value for <span class="stt">x</span> is 12. We update the
dictionary entry for <span class="stt">x</span> to 12. But the entry for <span class="stt">y</span> is
left alone:</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">Dictionary</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">Memory</span></p></td></tr><tr><td><p><span class="stt">-------------------------------------------------------------------</span></p></td></tr><tr><td><p><span class="stt">milk</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">--&gt; (loc 1000)</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">(loc 1000) --&gt; ToDoItem("buy milk" ...)</span></p></td></tr><tr><td><p><span class="stt">call1 --&gt; (loc 1001)</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">(loc 1001) --&gt; ToDoItem("call Tina" ...)</span></p></td></tr><tr><td><p><span class="stt">call2 --&gt; (loc 1002)</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">(loc 1002) --&gt; ToDoItem("call Fred" ...)</span></p></td></tr><tr><td><p><span class="stt">call3 --&gt; (loc 1001)</span></p></td></tr><tr><td><p><span class="stt">x</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">--&gt; 12</span></p></td></tr><tr><td><p><span class="stt">y</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">--&gt; 5</span></p></td></tr></table></p><h4>3.2<tt>&nbsp;</tt><a name="(part._.Wait_--_.So_.Names_.Don_t_.Track_.Each_.Other___)"></a>Wait &ndash; So Names Don&rsquo;t Track Each Other???</h4><p>Yesterday, we said that writing <span class="stt">call1 = call3</span> meant that
changes to one were visible to the other. But now we see that isn&rsquo;t
true for <span class="stt">x = y</span>. What&rsquo;s the difference?</p><p>There was a very subtle distinction here: yesterday, we changed the
<span style="font-style: italic">contents of a component of call1</span>. We didn&rsquo;t change the value
that <span class="stt">call1</span> refers to. This difference is HUGE. Changing
component contents updates memory, so names that refer to the same
address both see the change. Reassigning what a name <span style="font-style: italic">refers to</span>,
however, does not carry over across names.</p><div class="activity"><p>Setting one name equal to another does not mean that the two names
will always refer to the same value. Using <span class="stt">name = new_value</span>
changes the value associated only with <span class="stt">name</span>. Setting one name
equal to another when they refer to compound data means that changes
<span class="stt">within</span> that compound data are visible through both names.</p></div><p>This is a bit confusing at first &ndash; we know that.  We will continue to
work with these ideas in lecture, so you&rsquo;ll have time to get the hang
of it.</p><h3>4<tt>&nbsp;</tt><a name="(part._.Summary__.The_.Update_.Rules)"></a>Summary: The Update Rules</h3><div class="activity"><ul><li><p>We add to memory when a data constructor is used</p></li><li><p>We update memory when a field of existing data is reassigned</p></li><li><p>We add to the dictionary when a name is used for the first time (this
includes parameters and internal variables when a function is called)</p></li><li><p>We update the dictionary when a name that is already in the
dictionary is reassigned to a different value)</p></li></ul></div></div></div><div id="contextindicator">&nbsp;</div></body></html>