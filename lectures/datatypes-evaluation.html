<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>Class summary: Evaluating Programs that use Datatypes</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="scribble-style.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9658;</a></td><td></td><td><a href="" class="tocviewselflink" data-pltdoc="x">Class summary:<span class="mywbr"> &nbsp;</span> Evaluating Programs that use Datatypes</a></td></tr></table></div><div class="tocviewsublistonly" style="display: none;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="#%28part._.Recap__.Defining_.Datatypes%29" class="tocviewlink" data-pltdoc="x">Recap:<span class="mywbr"> &nbsp;</span> Defining Datatypes</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="#%28part._.Revisiting_how_.Programs_.Evaluate%29" class="tocviewlink" data-pltdoc="x">Revisiting how Programs Evaluate</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="#%28part._.Another_.Data_.Design_.Exercise%29" class="tocviewlink" data-pltdoc="x">Another Data Design Exercise</a></td></tr></table></div></div></div><div class="tocsub"><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber"></span><a href="#%28part._.Class_summary__.Evaluating_.Programs_that_use_.Datatypes%29" class="tocsubseclink" data-pltdoc="x">Class summary:<span class="mywbr"> &nbsp;</span> Evaluating Programs that use Datatypes</a></td></tr><tr><td><span class="tocsublinknumber">1<tt>&nbsp;</tt></span><a href="#%28part._.Recap__.Defining_.Datatypes%29" class="tocsubseclink" data-pltdoc="x">Recap:<span class="mywbr"> &nbsp;</span> Defining Datatypes</a></td></tr><tr><td><span class="tocsublinknumber">2<tt>&nbsp;</tt></span><a href="#%28part._.Revisiting_how_.Programs_.Evaluate%29" class="tocsubseclink" data-pltdoc="x">Revisiting how Programs Evaluate</a></td></tr><tr><td><span class="tocsublinknumber">2.1<tt>&nbsp;</tt></span><a href="#%28part._.The_.Program_.Dictionary%29" class="tocsubseclink" data-pltdoc="x">The Program Dictionary</a></td></tr><tr><td><span class="tocsublinknumber">2.2<tt>&nbsp;</tt></span><a href="#%28part._.Stepping_.Back%29" class="tocsubseclink" data-pltdoc="x">Stepping Back</a></td></tr><tr><td><span class="tocsublinknumber">3<tt>&nbsp;</tt></span><a href="#%28part._.Another_.Data_.Design_.Exercise%29" class="tocsubseclink" data-pltdoc="x">Another Data Design Exercise</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><h2><a name="(part._.Class_summary__.Evaluating_.Programs_that_use_.Datatypes)"></a>Class summary: Evaluating Programs that use Datatypes</h2><p>Copyright (c) 2017 Kathi Fisler</p><h3>1<tt>&nbsp;</tt><a name="(part._.Recap__.Defining_.Datatypes)"></a>Recap: Defining Datatypes</h3><p>Last class, we learned how to create our own datatypes, and how to
create values of those datatypes. Here&rsquo;s the <span class="stt">TimeData</span> type that
we created, and two examples of <span class="stt">time</span> values.</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">data TimeData:</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">| time(hour :: Number, mins :: Number)</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">end</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">noon = time(12, 0)</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">fivepm = time(17, 0)</span></p></td></tr></table></p><p>We also saw how to write functions that take our new datatype as
input.  Here is a different function than the one we wrote last week,
which determines whether one time is earlier than another.</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">fun earlier(td1 :: TimeData, td2 :: TimeData) -&gt; Boolean:</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">doc: "determine whether first time is earlier than second"</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">(td1.hour &lt; td2.hour) or</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">((td1.hour == td2.hour) and (td1.mins &lt; td2.mins))</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">where:</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">earlier(time(5,45), time(5, 46)) is true</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">earlier(time(5,45), time(5, 45)) is false</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">earlier(time(15,45), time(5, 46)) is false</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">earlier(time(5,45), time(15, 46)) is true</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">end</span></p></td></tr></table></p><h3>2<tt>&nbsp;</tt><a name="(part._.Revisiting_how_.Programs_.Evaluate)"></a>Revisiting how Programs Evaluate</h3><p>We have talked before about how when a function is called, Pyret
substitutes the arguments for the parameters. If we try that here, it
feels a bit heavyweight. What happens if we substitute from the first
example in our <span class="stt">where</span> clause?</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">earlier(time(5,45), time(5, 46)) is true</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">(time(5,45).hour &lt; time(5, 46).hour) or</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">((time(5,45).hour == time(5, 46).hour) and</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="stt">(time(5,45).mins &lt; time(5, 46).mins))</span></p></td></tr></table></p><p>If our datatypes had even more components, the substituted function
body could get rather large (and very hard to read). For a variety of
reasons, programming languages don&rsquo;t actually do substitution.
Instead, they keep track of what values each parameter maps to, and
they look up those values when they are accessed.</p><h4>2.1<tt>&nbsp;</tt><a name="(part._.The_.Program_.Dictionary)"></a>The Program Dictionary</h4><p>Early in the semester, we said that when we run a program, Pyret
maintains a record of all the definitions in the program.  This record
is called the <span style="font-style: italic">Program Dictionary</span>, and it is a mapping of names
(of functions and constants) to values.</p><p>We have said that when programs run, Pyret substitutes arguments to
functions in their bodies, looking up definitions when needed.
Actually, Pyret doesn&rsquo;t do substitution (though what it does is
equivalent). Actually, Pyret adds the parameters to the dictionary,
mapping them to the arguments supplied in the function call.</p><p>Assume your Pyret file contains the two code portions at the top of
the handout (the datatype definition, definition of <span class="stt">noon</span> and
definition of <span class="stt">earlier</span>). When you run the file, Pyret creates
the dictionary with the following contents:</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">noon --&gt; time(12, 0)</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">fivepm --&gt; time(17, 0)</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">earlier --&gt; function at line 8</span></p></td></tr></table></p><p>Now, assume you run <span class="stt">earlier(time(5,45), time(5, 46))</span>. Rather
than substitute, Pyret extends the dictionary</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">noon --&gt; time(12, 0)</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">fivepm --&gt; time(17, 0)</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">earlier --&gt; function at line 8</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">td1 --&gt; time(5, 45)</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">td2 --&gt; time(5, 46)</span></p></td></tr></table></p><p>then evaluates the body of <span class="stt">earlier</span>.  When it gets to an
expression like <span class="stt">td1.hour</span>, it looks up <span class="stt">td1</span> in the
dictionary, then extracts the <span class="stt">hour</span> component.</p><p>After running <span class="stt">earlier</span>, assume you enter <span class="stt">td1</span> at the
interactions prompt.  What will you get?  You&rsquo;ll get an unbound
identifier error. We&rsquo;ve said that the parameters are only visisble
within the body of the function, so this error makes sense.</p><p>But the dictionary we wrote has entries for <span class="stt">td1</span> and
<span class="stt">td2</span>. So what do we learn from the unbound identifier error?</p><p><span style="font-style: italic">When a function call ends, Pyret removes the entries for its
parameters from the dictionary.</span></p><p>Think of the dictionary being in segments, one for the entries made
when you initially run the program (the functions and constants), and
a separate segment for each function call:</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">noon --&gt; time(12, 0)</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">fivepm --&gt; time(17, 0)</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">earlier --&gt; function at line 8</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">------- &lt;call to earlier&gt; -------</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">td1 --&gt; time(5, 45)</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">td2 --&gt; time(5, 46)</span></p></td></tr></table></p><p>When a function call ends, it&rsquo;s segment is removed from the
dictionary.</p><p>If we then call <span class="stt">earlier</span> again, do we just replace the values
for <span class="stt">td1</span> and <span class="stt">td2</span>?  No &ndash; those entries were deleted when
the first call ended, so we simply add a new segment with the new
values for those parameters.</p><h4>2.2<tt>&nbsp;</tt><a name="(part._.Stepping_.Back)"></a>Stepping Back</h4><p>Why are we introducing the dictionary, instead of staying with
substitution?  Thinking in terms of dictionaries is easier once we
have values from datatypes with many components (which get painful to
copy as we do with substitution).  But more importantly, the
dictionary sets us up for some crucial ideas that we will confront
when we get to Python in November.</p><h3>3<tt>&nbsp;</tt><a name="(part._.Another_.Data_.Design_.Exercise)"></a>Another Data Design Exercise</h3><p>Calendar entries have a description, a date, a start time, and a
duration (in minutes). You want to write a program that helps someone
manage their calendar for an entire year. What combination of lists,
tables, and datatypes would you use?  Indicate the types of list
contents, the types of table columns, and define any new datatypes
that you need.</p><p>Possible ideas included:</p><ul><li><p>Have a list of tables, one per month</p></li><li><p>Have a table with one row per day, then a list of entries for
that day, where entries are a new datatype</p></li><li><p>Have a list of entries, where entries are a new datatype, with
no separation into months</p></li></ul><p>Which of these (or other) organizations makes sense depends heavily on
what computations you want to perform. If you are going to do many
calendar searches within a month, then an organization that clusters
entries by months will make it easier to focus in on the entries you
care about when doing a computation. If you will look mostly within a
day, maybe you want to cluster by days, and so on.</p><p>This example sets us up for a discussion we will have over the rest of
the course: how do we organize data to perform tasks efficiently?
Depending on your data organization, computations can be faster or
slower. We&rsquo;re ready to start exploring these issues.</p></div></div><div id="contextindicator">&nbsp;</div></body></html>