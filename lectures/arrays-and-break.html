<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>Class summary: Arrays and Break</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="scribble-style.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9658;</a></td><td></td><td><a href="" class="tocviewselflink" data-pltdoc="x">Class summary:<span class="mywbr"> &nbsp;</span> Arrays and Break</a></td></tr></table></div><div class="tocviewsublistonly" style="display: none;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="#%28part._.The_internal_structure_of_lists%29" class="tocviewlink" data-pltdoc="x">The internal structure of lists</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="#%28part._.Back_to_the_.Runners%29" class="tocviewlink" data-pltdoc="x">Back to the Runners</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="#%28part._.The_.Role_of_.Variables%29" class="tocviewlink" data-pltdoc="x">The Role of Variables</a></td></tr></table></div></div></div><div class="tocsub"><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber"></span><a href="#%28part._.Class_summary__.Arrays_and_.Break%29" class="tocsubseclink" data-pltdoc="x">Class summary:<span class="mywbr"> &nbsp;</span> Arrays and Break</a></td></tr><tr><td><span class="tocsublinknumber">1<tt>&nbsp;</tt></span><a href="#%28part._.The_internal_structure_of_lists%29" class="tocsubseclink" data-pltdoc="x">The internal structure of lists</a></td></tr><tr><td><span class="tocsublinknumber">1.1<tt>&nbsp;</tt></span><a href="#%28part._.Two_.Memory_.Layouts_for_.Ordered_.Items%29" class="tocsubseclink" data-pltdoc="x">Two Memory Layouts for Ordered Items</a></td></tr><tr><td><span class="tocsublinknumber">2<tt>&nbsp;</tt></span><a href="#%28part._.Back_to_the_.Runners%29" class="tocsubseclink" data-pltdoc="x">Back to the Runners</a></td></tr><tr><td><span class="tocsublinknumber">2.1<tt>&nbsp;</tt></span><a href="#%28part._.Printing_instead_of_returning_runners%29" class="tocsubseclink" data-pltdoc="x">Printing instead of returning runners</a></td></tr><tr><td><span class="tocsublinknumber">3<tt>&nbsp;</tt></span><a href="#%28part._.The_.Role_of_.Variables%29" class="tocsubseclink" data-pltdoc="x">The Role of Variables</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><h2><a name="(part._.Class_summary__.Arrays_and_.Break)"></a>Class summary: Arrays and Break</h2><p>Copyright (c) 2017 Kathi Fisler</p><h3>1<tt>&nbsp;</tt><a name="(part._.The_internal_structure_of_lists)"></a>The internal structure of lists</h3><p>Last lecture, we ended with a question about how fast one can access a
specific element of a list.  Specifically, if you have a list called
<span style="font-style: italic">finishers</span> of Runners (our example from last time) and you
write:</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">finishers[9]</span></p></td></tr></table></p><p>How long does it take to locate the Runner in 10th place (remember,
indices start at 0)?</p><p>It depends on how the list is laid out in memory.</p><h4>1.1<tt>&nbsp;</tt><a name="(part._.Two_.Memory_.Layouts_for_.Ordered_.Items)"></a>Two Memory Layouts for Ordered Items</h4><p>When we say "list", we usually mean simply: a collection of items with
order. How might a collection of ordered items be arranged in memory?
Here are two examples, using a list of course names:</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">courses = ["CS111", "ENGN90", "VISA100"]</span></p></td></tr></table></p><p>In the first version, the elements are laid out in consecutive memory
locations (this is rougly how we&rsquo;ve shown lists up to now):</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">Prog Dictionary</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">Memory</span></p></td></tr><tr><td><p><span class="stt">--------------------------------------------------------------------</span></p></td></tr><tr><td><p><span class="stt">courses --&gt; loc 1001</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">loc 1001 --&gt; [loc 1002, loc1003, loc 1004]</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">loc 1002 --&gt; "CS111"</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">loc 1003 --&gt; "ENGN90"</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">loc 1004 --&gt; "VISA100"</span></p></td></tr></table></p><p>In the second version, each element is captured as a datatype
containing the element and the next list location. When we were in
Pyret, this datatype was called <span class="stt">link</span>.</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">Prog Dictionary</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">Memory</span></p></td></tr><tr><td><p><span class="stt">--------------------------------------------------------------------</span></p></td></tr><tr><td><p><span class="stt">courses --&gt; loc 1001</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">loc 1001 --&gt; link("CS111", loc 1002)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">loc 1002 --&gt; link("ENGN90", loc 1003)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">loc 1003 --&gt; link("VISA100", loc 1004)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">loc 1004 --&gt; empty</span></p></td></tr></table></p><p>What are the tradeoffs between the two versions?  In the first, we can
access items by index in constant time, as we could for hashtables,
but changing the contents (adding or deleting) requires moving things
around in memory.  In the second, the size of the collection can grow
or shrink arbitrarily, but it takes time proportional to the index to
look up a specific value.  Each organization has its place in some
programs.</p><p>In data structures terms, the first organization is called an
<span style="font-style: italic">array</span>.  The second is called a <span style="font-style: italic">linked list</span>.  Pyret
implements linked lists, with arrays being a separate data type (with
a different notation from lists). Python implements lists as
arrays. When you approach a new programming language, you need to look
up whether its lists are linked lists or arrays if you care about the
run-time performance of the underlying operations.</p><h3>2<tt>&nbsp;</tt><a name="(part._.Back_to_the_.Runners)"></a>Back to the Runners</h3><p>Going back to our Runners discussion from last class, we can simply
use Python lists (arrays) rather than a hashtable, and be able to
access the names of Runners who finished in particular positions. But
let&rsquo;s instead ask a different question.</p><p>How would we report the top finishers in each age category? In
particular, we want to write a function such as the following:</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">def top_5_range(runners: list, lo: int, high: int) -&gt; list:</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">"""get list of top 5 finishers with ages in</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">the range given by lo to high, inclusive</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">"""</span></p></td></tr></table></p><p><span style="font-weight: bold">Think about how you would write this code.</span></p><p>Here&rsquo;s our solution:</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">def top_5_range(runners: list, lo: int, high: int) -&gt; list:</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">"""get list of top 5 finishers with ages in</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">the range given by lo to high, inclusive</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">"""</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"># count of runners seen who are in age range</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">in_range: int = 0</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"># the list of finishers</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">result: list = []</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">for r in runners:</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">if lo &lt;= r.age and r.age &lt;= high:</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">in_range += 1</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">result.append(r)</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">if in_range == 5:</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">return result</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">print("Fewer than five in category")</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">return result</span></p></td></tr></table></p><p>Here, rather than return only when we get to the end of the list, we
want to return once we have five runners in the list. So we set up an
additional variable (<span class="stt">in_range</span>) to help us track progress of the
computation. Once we have gotten to 5 runners, we return the list. If
we never get to 5 runners, we print a warning to the user then return
the results that we do have.</p><p>Couldn&rsquo;t we have just looked at the length of the list, rather than
maintain the <span class="stt">in_range</span> variable?  Yes, we could have, though
this version sets up a contrast to our next example.</p><h4>2.1<tt>&nbsp;</tt><a name="(part._.Printing_instead_of_returning_runners)"></a>Printing instead of returning runners</h4><p>What if instead we just wanted to print out the top 5 finishers,
rather than gather a list?  While in general it is usually better to
separate computing and displaying data, in practice we do sometimes
merge them, or do other operations (like write some data to file)
which won&rsquo;t return anything. How do we modify the code to print the
names rather than build up a list of the runners?</p><p>The challenge here is how to stop the computation. When we are
building up a list, we stop a computation using return. But if our
code isn&rsquo;t returning, or otherwise needs to stop a loop before it
reaches the end of the data, what do we do?</p><p>We use a command called <span class="stt">break</span>, which says to terminate the loop
and continue the rest of the computation. Here, the break is in place
of the inner return statement:</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">def print_top_5_range(runners: list, lo: int, high: int):</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">"""print top 5 finishers with ages in</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">the range given by lo to high, inclusive</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">"""</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"># count of runners seen who are in age range</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">in_range: int = 0</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">for r in runners:</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">if lo &lt;= r.age and r.age &lt;= high:</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">in_range += 1</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">print(r.name)</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">if in_range == 5:</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">break</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">print("End of results")</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr></table></p><p>If Python reaches the <span class="stt">break</span> statement, it terminates the for
loop and goes to the next statement, which is the print at the end of
the function.</p><h3>3<tt>&nbsp;</tt><a name="(part._.The_.Role_of_.Variables)"></a>The Role of Variables</h3><p>This example also gives us a chance to review when to use variables in
programming. If we look at these examples, we have two (or three)
variables:</p><ul><li><p>finishers</p></li><li><p>in_range</p></li><li><p>result (in one version)</p></li></ul><p>These variables illustrate two different roles that variables and
updates to them play in programs:</p><ul><li><p>Maintaining data across calls to functions of a program</p></li><li><p>Tracking progress of a computation</p></li></ul><p>The variables we have created to hold hashtables, lists like
<span class="stt">finishers</span>, the collections of bank accounts, and the
<span class="stt">next_id</span> for a new account are in the first category: we have
multiple operations (or multiple calls to the same operation) that
need to update and/or lookup in a common piece of data. We use a
variable to name that data so all functions can access it over time.</p><p>Variables like <span class="stt">in_range</span> and <span class="stt">result</span> in our
<span class="stt">top_5_range</span> program(s) are of the second kind. They aren&rsquo;t
being maintained over time or across function calls, but they are
tracking progress of a computation so we can either tell when we are
done or build up a local answer to return after a computation
finishes.</p><p>If you see the need for either of these patterns &ndash; shared data or the
need to track information to finish a computation &ndash; you&rsquo;ll create a
variable to manage it.</p><p><span style="font-style: italic">This leaves a question to ponder &ndash; why did we not need
variables in Pyret?  Can we write programs like <span class="stt">top_5_range</span> in
Pyret?  What does the tracking of progress there?</span></p></div></div><div id="contextindicator">&nbsp;</div></body></html>