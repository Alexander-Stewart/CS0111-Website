<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>Class summary: Circular References and Intro to Hashtables</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="notes.css" title="default"/><link rel="stylesheet" type="text/css" href="scribble-style.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9658;</a></td><td></td><td><a href="" class="tocviewselflink" data-pltdoc="x">Class summary:<span class="mywbr"> &nbsp;</span> Circular References and Intro to Hashtables</a></td></tr></table></div><div class="tocviewsublistonly" style="display: none;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="#%28part._.Circular_.References%29" class="tocviewlink" data-pltdoc="x">Circular References</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="#%28part._.Introduction_to_.Hashtables%29" class="tocviewlink" data-pltdoc="x">Introduction to Hashtables</a></td></tr></table></div></div></div><div class="tocsub"><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber"></span><a href="#%28part._.Class_summary__.Circular_.References_and_.Intro_to_.Hashtables%29" class="tocsubseclink" data-pltdoc="x">Class summary:<span class="mywbr"> &nbsp;</span> Circular References and Intro to Hashtables</a></td></tr><tr><td><span class="tocsublinknumber">1<tt>&nbsp;</tt></span><a href="#%28part._.Circular_.References%29" class="tocsubseclink" data-pltdoc="x">Circular References</a></td></tr><tr><td><span class="tocsublinknumber">1.1<tt>&nbsp;</tt></span><a href="#%28part._.Use_assignment_to_create_circular_data%29" class="tocsubseclink" data-pltdoc="x">Use assignment to create circular data</a></td></tr><tr><td><span class="tocsublinknumber">1.2<tt>&nbsp;</tt></span><a href="#%28part._.Testing_.Circular_.Data%29" class="tocsubseclink" data-pltdoc="x">Testing Circular Data</a></td></tr><tr><td><span class="tocsublinknumber">1.3<tt>&nbsp;</tt></span><a href="#%28part._.Bonus__.A_.Function_to_.Create_.Accounts_for_.New_.Customers%29" class="tocsubseclink" data-pltdoc="x">Bonus:<span class="mywbr"> &nbsp;</span> A Function to Create Accounts for New Customers</a></td></tr><tr><td><span class="tocsublinknumber">2<tt>&nbsp;</tt></span><a href="#%28part._.Introduction_to_.Hashtables%29" class="tocsubseclink" data-pltdoc="x">Introduction to Hashtables</a></td></tr><tr><td><span class="tocsublinknumber">2.1<tt>&nbsp;</tt></span><a href="#%28part._.Finding_.Items_in_.Memory%29" class="tocsubseclink" data-pltdoc="x">Finding Items in Memory</a></td></tr><tr><td><span class="tocsublinknumber">2.2<tt>&nbsp;</tt></span><a href="#%28part._.The_.Hashtable_.Datatype%29" class="tocsubseclink" data-pltdoc="x">The Hashtable Datatype</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><h2><a name="(part._.Class_summary__.Circular_.References_and_.Intro_to_.Hashtables)"></a>Class summary: Circular References and Intro to Hashtables</h2><p>Copyright (c) 2017 Kathi Fisler</p><h3>1<tt>&nbsp;</tt><a name="(part._.Circular_.References)"></a>Circular References</h3><p>One of the interesting things about our Book and Patron definitions is
that they refer to each other: A patron refers to books, which refer
to their borrowers, which refer to their books, and so on.  Let&rsquo;s look
at these circular dependencies in data a bit more closely.</p><p>Here are versions of the Account and Customer classes that set up a
circular reference: each Account refers to its owners, and each
Customer refers to their account. To keep the example simple, we will
assume that each Customer can have only one account.</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">@dataclass</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">class Account:</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">id: int</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">balance: int</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">owners: list # of Customer</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">@dataclass</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">class Customer:</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">name: str</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">acct: Account</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr></table></p><p>Let&rsquo;s now create a new customer and a new account for them:</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">new_acct = Account(5, 150, Customer("Kathi", __________))</span></p></td></tr></table></p><p>How do we fill in the blank in the Customer? We&rsquo;d like to say
<span class="stt">new_acct</span> but Python (and most other languages) will raise an
error that <span class="stt">new_acct</span> isn&rsquo;t defined.  Why is that?</p><p>When given this assignment, Python first evaluates the right side, to
get the value or memory location that should be stored in the
dictionary for <span class="stt">new_acct</span>.  If we filled in the blank with
<span class="stt">new_acct</span>, Python would start by running:</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">Account(5, 150, Customer("Kathi", new_acct))</span></p></td></tr></table></p><p>To do this, it needs to look up <span class="stt">new_acct</span> in the dictionary, but
that name isn&rsquo;t in the dictionary yet (it only goes in after we
compute the value to store for that name). Hence the error.</p><h4>1.1<tt>&nbsp;</tt><a name="(part._.Use_assignment_to_create_circular_data)"></a>Use assignment to create circular data</h4><p>To get around this, we leverage the ability to update the contents of
memory locations after names for data are in place. We&rsquo;ll create the
account partially, but without filling in the Customer. Then we create
the customer to reference the new Account. Then we update the account
owners with the now-created customer:</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">new_acct = Account(5, 150, [])</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt"># note the empty Customer list</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">new_cust = Customer("Kathi", new_acct)</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">new_acct.owners = [new_cust]</span></p></td></tr></table></p><p>Note here that each part gets a spot in memory and an entry in the
dictionary, but the data hasn&rsquo;t been finished yet. Once we have the
data set up in memory though, we can update the owners component to
the correct value.</p><p>Here&rsquo;s what this looks like at the level of memory and the dictionary
after running the first two lines:</p><div class="highlight"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">Dictionary</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">Memory</span></p></td></tr><tr><td><p><span class="stt">-----------------------------------------------------------------------</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">(loc 1015) -&gt; []</span></p></td></tr><tr><td><p><span class="stt">new_acct -&gt; (loc 1016)</span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="stt">(loc 1016) -&gt; Account(5, 150, loc 1015)</span></p></td></tr><tr><td><p><span class="stt">new_cust -&gt; (loc 1017)</span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="stt">(loc 1017) -&gt; Customer("Kathi", loc 1016)</span></p></td></tr></table></div><p>Then, when we run the third line, we create a new list containing
<span class="stt">new_cust</span> and update the owner list within <span class="stt">new_acct</span>:</p><div class="highlight"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">Dictionary</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">Memory</span></p></td></tr><tr><td><p><span class="stt">-----------------------------------------------------------------------</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">(loc 1015) -&gt; []</span></p></td></tr><tr><td><p><span class="stt">new_acct -&gt; (loc 1016)</span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="stt">(loc 1016) -&gt; Account(5, 150, loc 1018)</span></p></td></tr><tr><td><p><span class="stt">new_cust -&gt; (loc 1017)</span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="stt">(loc 1017) -&gt; Customer("Kathi", loc 1016)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">(loc 1018) -&gt; [loc 1017]</span></p></td></tr></table></div><p>Notice that the two owners lists each live in memory but aren&rsquo;t
associated with names in the dictionary. They are only reachable going
through <span class="stt">new_acct</span>, and after the update, the empty list isn&rsquo;t
reachable at all.</p><p>If we had instead done the owner update using <span class="stt">append</span>, as in:</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">new_acct = Account(5, 150, [])</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt"># note the empty Customer list</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">new_cust = Customer("Kathi", new_acct)</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">new_acct.owners.append(new_cust)</span></p></td></tr></table></p><p>We would have updated the list at location 1015 instead of create a
new location for a new list, as follows:</p><div class="highlight"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">Dictionary</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">Memory</span></p></td></tr><tr><td><p><span class="stt">-----------------------------------------------------------------------</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">(loc 1015) -&gt; [loc 1017]</span></p></td></tr><tr><td><p><span class="stt">new_acct -&gt; (loc 1016)</span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="stt">(loc 1016) -&gt; Account(5, 150, loc 1015)</span></p></td></tr><tr><td><p><span class="stt">new_cust -&gt; (loc 1017)</span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="stt">(loc 1017) -&gt; Customer("Kathi", loc 1016)</span></p></td></tr></table></div><p>Either approach (append or a new list) works fine. The only difference
is whether a new list gets created, as shown in these two memory examples.</p><h4>1.2<tt>&nbsp;</tt><a name="(part._.Testing_.Circular_.Data)"></a>Testing Circular Data</h4><p>When you want to write a test involving circular data, you can&rsquo;t write
out the circluar data manually.  For example, imagine that we wanted
to write out new_acct from the previous examples:</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">test("data test", new_acct,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">Account(5, 150, [Customer("Kathi", Account(5, 150, ...)])</span></p></td></tr></table></p><p>Because of the circularity, you can&rsquo;t finish writing down the
data. You have two options: write tests in terms of the names of data,
or write tests on the components of the data.</p><p>Here&rsquo;s an example that illustrates both. After setting up the account,
we might want to check that the owner of the new account is the new
customer:</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">test("new owner", new_acct.owner, new_cust)</span></p></td></tr></table></p><p>Here, rather than write out the Customer by hand, we drop in the name
of the existing item in memory. This doesn&rsquo;t require you to write
ellipses. We also focused on just the owner component, as a part of
the Account value that we expected to change.</p><h4>1.3<tt>&nbsp;</tt><a name="(part._.Bonus__.A_.Function_to_.Create_.Accounts_for_.New_.Customers)"></a>Bonus: A Function to Create Accounts for New Customers</h4><p>What if we turned the sequence for creating dependencies between
customers and their accounts into a function?  We might get something
like the following:</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">def create_acct(new_id: int, init_bal: int, cust_name: str) -&gt; Account:</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">new_acct = Account(new_id, init_bal, [])</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt"># note the empty Customer list</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">new_cust = Customer(cust_name, new_acct)</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">new_acct.owners.append(new_cust)</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">return new_acct</span></p></td></tr></table></p><p>This looks useful, but it does have a flaw &ndash; we could accidentally
create two accounts with the same id number. It would be better for us
to maintain a variable containing the next account id to use, to
guarantee that the same id gets used only once.  How might we augment
the code to do this?</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">next_id = 1 # stores the next available id number</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">def create_acct(init_bal: int, cust_name: str) -&gt; Account:</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">new_acct = Account(next_id, init_bal, [])</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt"># note the empty Customer list</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">next_id = next_id + 1</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">new_cust = Customer(cust_name, new_acct)</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">new_acct.owners.append(new_cust)</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">return new_acct</span></p></td></tr></table></p><p>Here, we create the <span class="stt">next_id</span> variable to hold the next id number
to use. When we create an Account, we update <span class="stt">next_id</span> to the
next unused number.  Problem solved!</p><p>Well, almost.  Now we&rsquo;re at something that is specific to Python.</p><p>When we were still working in Pyret, we talked about what happens to
the dictionary when we call a function: we make a separate area of the
dictionary for that function, and we put the values of the parameters
in that area of the dictionary.  When the function ends, its piece of
dictionary goes away.</p><p>In our code above, we have a variable <span class="stt">next_id</span> set up outside
the <span class="stt">create_acct</span> function.  Inside the function, we are
assigning to a variable <span class="stt">next_id</span>.  Is this the same variable
from outside the function though, or are we trying to create a new
variable (as we do for <span class="stt">new_acct</span> or <span class="stt">new_cust</span>). Python
can&rsquo;t tell which one we want.</p><p>To tell Python that we are trying to use the copy of the variable that
is outside the function, we have to add a line telling it that. We do
that by using a <span class="stt">global</span> annotation inside the function. Here&rsquo;s
the final code:</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">next_id = 1 # stores the next available id number</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">def create_acct(init_bal: int, cust_name: str) -&gt; Account:</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt"># next line says to use the next_id from outside the function</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">global next_id</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">new_acct = Account(next_id, init_bal, [])</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt"># note the empty Customer list</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">next_id = next_id + 1</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">new_cust = Customer(cust_name, new_acct)</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">new_acct.owners.append(new_cust)</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">return new_acct</span></p></td></tr></table></p><p><span style="font-style: italic">This isn&rsquo;t something you&rsquo;ll be tested on &ndash; it is just here to
show you how to do this in case you are interested.</span></p><h3>2<tt>&nbsp;</tt><a name="(part._.Introduction_to_.Hashtables)"></a>Introduction to Hashtables</h3><h4>2.1<tt>&nbsp;</tt><a name="(part._.Finding_.Items_in_.Memory)"></a>Finding Items in Memory</h4><p>When someone asks for an account balance, they usually provide their
account number. This suggests that we need a function that takes an
account number and returns the account value with that id. From there,
we can dig into the account to get the balance.</p><p>This means we need some data structure to store all of the
accounts. We&rsquo;ve seen lists and tables for this purpose. Let&rsquo;s use a
(Python) list. Such a list might look as follows:</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">all_accts = [Account(8, 100, []),</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">Account(2, 300, []),</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">Account(10, 225, []),</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">Account(3, 200, []),</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">Account(1, 120, []),</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">...</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">]</span></p></td></tr></table></p><p>For now, we&rsquo;ll ignore the owners component &ndash; it isn&rsquo;t relevant to our
discussion and omitting it will make examples easier to write out.</p><p>So we need to search a list for the account with a given id.  We&rsquo;ve
written such search code many times at this point. Here it is again
for reference, with a Python test function for good measure:</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">def find_acct(which_id : int, acct_list : list) -&gt; Account:</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">"""returns the account with the given id number"""</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">for acct in acct_list:</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">if acct.id == which_id:</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">return acct</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">raise ValueError("no account has id " + str(which_id))</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">def test_find():</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">test("match num", find_acct(3, all_accts).id, 3)</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">test("match exactly", find_acct(1, all_accts).id, 1)</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">testValueError("no account", lambda: find_acct(22, all_accts))</span></p></td></tr></table></p><p>As we discussed earlier in the course, this function takes linear time
in the number of accounts in the worst case.  For a real bank, that&rsquo;s
a significant number. How can we do better?</p><p>Now that we&rsquo;ve been thinking about memory a bit, we can reframe the
question about finding an account.  Finding an account is ultimately
about <span style="font-style: italic">finding the account in memory</span>. Once we know the memory
location of the account we&rsquo;re trying to find, we can operate on that
account however we want.</p><p>In the <span class="stt">find_acct</span> version, we use the dictionary to find the
list in memory, then iterate through all the accounts in the list,
checking their ids until we find the one that we want. But what if we
had a way to predict where the account we want would be, so we could
go directly to that memory location?  Could we have to set up the data
to enable that?</p><p>Looking at our memory diagrams, we see that the items in the list are
in order in memory. So if we know which position we want within the
list, we should be able to hop to that spot immediately once we know
the memory location of the list itself (basically, we take the address
of the list itself and add the list position to get to the right
memory spot).  Things are a touch more complicated than this in
practice (because we&rsquo;ve simplified the structure of lists in memory
the last several lectures), but this is the intuition.</p><p>There&rsquo;s nothing in the programming language that lets us grab memory
locations from the dictionary and add offsets to them for specific
elements.  But there are data structures that effectively do that for
you.  Enter the hashtable.</p><h4>2.2<tt>&nbsp;</tt><a name="(part._.The_.Hashtable_.Datatype)"></a>The Hashtable Datatype</h4><p>For today, we&rsquo;re just going to show you a hashtable and how to use
it. Next class, we&rsquo;ll discuss how it works.</p><p>Hashtables are data structures that let us map quickly from some
notion of keys (like account numbers or course codes) to values. When
we set up a hashtable, we write a series of entries of the form</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">key: value</span></p></td></tr></table></p><p>Here&rsquo;s what a hashtable mapping id numbers to accounts might look
like:</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">accts_HM = {5: Account(5, 225, []),</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">3: Account(3, 200, []),</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">2: Account(2, 300, []),</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">4: Account(4,</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">75, []),</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">1: Account(1, 100, [])</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">}</span></p></td></tr></table></p><p>We create a hashtable by using curly braces instead of square brackets
(as we do for creating lists) on the outside, and by using the
<span class="stt">key: value</span> form for each item. The hashtable above has five
account IDs that map to accounts with those same ID numbers.</p><p>Now, if we want to get the account with ID 1 from the hashmap, we can
simply write:</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">accts_HM[1]</span></p></td></tr></table></p><p>This says "in the <span class="stt">accts_HM</span> hashtable, get the value associated
with key <span class="stt">1</span>.  Because of the way hashtables are set up within
Python (and any other language), Python can hop to the memory address
in constant time and extract the <span class="stt">Account</span> with ID 1.</p><p>There are many more things to discuss about hashtables: how to use
keys that aren&rsquo;t numbers, how they work, and when to use them.  All of
these are coming up in the next couple of lectures.</p></div></div><div id="contextindicator">&nbsp;</div></body></html>