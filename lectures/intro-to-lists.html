<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>Class summary: Introduction to Lists</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="scribble-style.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9658;</a></td><td></td><td><a href="" class="tocviewselflink" data-pltdoc="x">Class summary:<span class="mywbr"> &nbsp;</span> Introduction to Lists</a></td></tr></table></div><div class="tocviewsublistonly" style="display: none;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="#%28part._.Looking_up_values_by_keys%29" class="tocviewlink" data-pltdoc="x">Looking up values by keys</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="#%28part._.Lists__.Two_.Motivating_.Problems%29" class="tocviewlink" data-pltdoc="x">Lists:<span class="mywbr"> &nbsp;</span> Two Motivating Problems</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="#%28part._.Lists__a_new_kind_of_data_for_sets%29" class="tocviewlink" data-pltdoc="x">Lists:<span class="mywbr"> &nbsp;</span> a new kind of data for sets</a></td></tr><tr><td align="right">4&nbsp;</td><td><a href="#%28part._.What_are_.Lists_%29" class="tocviewlink" data-pltdoc="x">What are Lists?</a></td></tr><tr><td align="right">5&nbsp;</td><td><a href="#%28part._.Extracting_.Lists_from_.Tables%29" class="tocviewlink" data-pltdoc="x">Extracting Lists from Tables</a></td></tr></table></div></div></div><div class="tocsub"><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber"></span><a href="#%28part._.Class_summary__.Introduction_to_.Lists%29" class="tocsubseclink" data-pltdoc="x">Class summary:<span class="mywbr"> &nbsp;</span> Introduction to Lists</a></td></tr><tr><td><span class="tocsublinknumber">1<tt>&nbsp;</tt></span><a href="#%28part._.Looking_up_values_by_keys%29" class="tocsubseclink" data-pltdoc="x">Looking up values by keys</a></td></tr><tr><td><span class="tocsublinknumber">2<tt>&nbsp;</tt></span><a href="#%28part._.Lists__.Two_.Motivating_.Problems%29" class="tocsubseclink" data-pltdoc="x">Lists:<span class="mywbr"> &nbsp;</span> Two Motivating Problems</a></td></tr><tr><td><span class="tocsublinknumber">3<tt>&nbsp;</tt></span><a href="#%28part._.Lists__a_new_kind_of_data_for_sets%29" class="tocsubseclink" data-pltdoc="x">Lists:<span class="mywbr"> &nbsp;</span> a new kind of data for sets</a></td></tr><tr><td><span class="tocsublinknumber">4<tt>&nbsp;</tt></span><a href="#%28part._.What_are_.Lists_%29" class="tocsubseclink" data-pltdoc="x">What are Lists?</a></td></tr><tr><td><span class="tocsublinknumber">5<tt>&nbsp;</tt></span><a href="#%28part._.Extracting_.Lists_from_.Tables%29" class="tocsubseclink" data-pltdoc="x">Extracting Lists from Tables</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><h2><a name="(part._.Class_summary__.Introduction_to_.Lists)"></a>Class summary: Introduction to Lists</h2><p>Copyright (c) 2017 Kathi Fisler</p><h3>1<tt>&nbsp;</tt><a name="(part._.Looking_up_values_by_keys)"></a>Looking up values by keys</h3><p>We want a function that takes the name of a person and returns the
number of tickets they have ordered:</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">fun tickets-for(t :: Table, who :: String) -&gt; Number:</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">doc: "Extract tickcount value for order with given name"</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">...</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">where:</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">tickets-for(event-data-clean, "Alvina") is 3</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">tickets-for(event-data-clean, "Ernie") is 0</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">end</span></p></td></tr></table></p><p>We filled in the body as follows:</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">fun tickets-for(t :: Table, who :: String) -&gt; Number:</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">doc: "Extract tickcount value for order with given name"</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">matches = filter-by(t, lam(r): r["name"] == who end)</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">matches.row-n(0)["tickcount"]</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">where:</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">tickets-for(event-data-clean, "Alvina") is 3</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">tickets-for(event-data-clean, "Ernie") is 0</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">end</span></p></td></tr></table></p><p>What happens if we try the following?</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">tickets-for(event-data-clean,"kathi")</span></p></td></tr></table></p><p>Our current code assumes that <span class="stt">filter-by</span> will return a non-empty
table. We should instead check that we got a non-empty table, and
raise an error if we did not:</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">fun tickets-for(t :: Table, who :: String) -&gt; Number:</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">doc: "Extract tickcount value for order with given name"</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">matches = filter-by(t, lam(r): r["name"] == who end)</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">if matches.length() &gt; 0:</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">matches.row-n(0)["tickcount"]</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">else:</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">raise("Tickets-for: table has no row with name " + who)</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">end</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">where:</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">tickets-for(event-data-clean, "Alvina") is 3</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">tickets-for(event-data-clean, "Ernie") is 0</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">tickets-for(event-data-clean, "Kathi") raises "no row"</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">end</span></p></td></tr></table></p><p>The where clause shows how to check whether a call to the function
results in an error being raised &ndash; rather than write <span style="font-weight: bold">is</span> in the
example, we write <span style="font-weight: bold">raises</span>. The string after <span style="font-weight: bold">raises</span> needs
to be a substring of the raised error for the test to pass.</p><h3>2<tt>&nbsp;</tt><a name="(part._.Lists__.Two_.Motivating_.Problems)"></a>Lists: Two Motivating Problems</h3><p>Consider the following two questions:</p><ul><li><p>Is every discount in the table from a valid set of discount codes?</p></li><li><p>What are the names of everyone with the student discount?</p></li></ul><p>We have an idea of how to write the first one &ndash; a <span class="stt">filter-by</span>
with a helper function that uses <span class="stt">or</span> to check the code against a
collection of options:</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">fun check-discounts1(t :: Table) -&gt; Table:</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">doc: "filter out rows whose discount code is not valid"</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">fun invalid-code(r :: Row) -&gt; Boolean:</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">not(</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">(r["discount"] == "STUDENT") or</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">(r["discount"] == "BIRTHDAY") or</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">(r["discount"] == "") or</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">(r["discount"] == "EARLYBIRD"))</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">end</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">filter-by(t, invalid-code)</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">end</span></p></td></tr></table></p><p>There&rsquo;s something unsatisfying about this solution, though: every time
the set of codes changes, we have to change the function. It would be
much nicer if the codes could be written independently of the
function. Then, the sales department could change the codes without
having to bother the programmers every time.</p><p>So the real question is how can we rewrite this function so that the
set of valid codes is written down outside the function?</p><h3>3<tt>&nbsp;</tt><a name="(part._.Lists__a_new_kind_of_data_for_sets)"></a>Lists: a new kind of data for sets</h3><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">valid-discounts = [list: "STUDENT", "BIRTHDAY", "", "EARLYBIRD"]</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">fun check-discounts(t :: Table) -&gt; Table:</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">doc: "filter out rows whose discount code is not valid"</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">fun invalid-code(r :: Row) -&gt; Boolean:</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">not(L.member(valid-discounts, r["discount"]))</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">end</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">filter-by(t, invalid-code)</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">where:</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">check-discounts(event-data)</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">is</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">add-row(</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">add-row(</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">add-row(event-data.empty(), event-data.row-n(3)),</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">event-data.row-n(4)),</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">event-data.row-n(6))</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">end</span></p></td></tr></table></p><p>Here is a version written with anonymous functions/<span class="stt">lambda</span>.</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">fun check-discounts2(t :: Table) -&gt; Table:</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">doc: "filter out rows whose discount code is not valid"</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">filter-by(t, lam(r): not(L.member(valid-discounts, r["discount"])) end)</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">where:</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">check-discounts2(event-data)</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">is</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">add-row(</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">add-row(</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">add-row(event-data.empty(), event-data.row-n(3)),</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">event-data.row-n(4)),</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">event-data.row-n(6))</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">end</span></p></td></tr></table></p><h3>4<tt>&nbsp;</tt><a name="(part._.What_are_.Lists_)"></a>What are Lists?</h3><p>Lists are one of the key data structures in programming. They feature:</p><ul><li><p>An unbounded number of items</p></li><li><p>An order on items (first, second, third, ...)</p></li></ul><p>As we will see, there are many built-in operations on lists.</p><h3>5<tt>&nbsp;</tt><a name="(part._.Extracting_.Lists_from_.Tables)"></a>Extracting Lists from Tables</h3><p>Turning to the second question, how could we get a list of names of
people with the <span class="stt">"STUDENT"</span> discount? (Perhaps we want to validate
those names against data from a school).</p><p>We know how to filter the table down to only those rows that have
<span class="stt">"STUDENT"</span> in the discount column.  How do we get the names from
those rows?  We use a table operator called <span class="stt">get-column</span> that
pulls out the values from a column as a list:</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">filter-by(</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="stt">event-data-clean,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="stt">lam(r): r["discount"] == "STUDENT" end).get-column("name")</span></p></td></tr></table></p><p>Alternatively, using an intermediate name for the filtered table:</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">rows =</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">filter-by(</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">event-data-clean,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">lam(r): r["discount"] == "STUDENT" end)</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">rows.get-column("name")</span></p></td></tr></table></p><p>We&rsquo;ll do a lot more with lists over the next several classes.</p></div></div><div id="contextindicator">&nbsp;</div></body></html>