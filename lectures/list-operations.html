<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>Class summary: Operations on Lists</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="scribble-style.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9658;</a></td><td></td><td><a href="" class="tocviewselflink" data-pltdoc="x">Class summary:<span class="mywbr"> &nbsp;</span> Operations on Lists</a></td></tr></table></div><div class="tocviewsublistonly" style="display: none;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="#%28part._.Categorizing_.Pizza_.Toppings%29" class="tocviewlink" data-pltdoc="x">Categorizing Pizza Toppings</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="#%28part._.Combining_.Map_and_.Filter%29" class="tocviewlink" data-pltdoc="x">Combining Map and Filter</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="#%28part._.Summary_of_.List_.Operations%29" class="tocviewlink" data-pltdoc="x">Summary of List Operations</a></td></tr></table></div></div></div><div class="tocsub"><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber"></span><a href="#%28part._.Class_summary__.Operations_on_.Lists%29" class="tocsubseclink" data-pltdoc="x">Class summary:<span class="mywbr"> &nbsp;</span> Operations on Lists</a></td></tr><tr><td><span class="tocsublinknumber">1<tt>&nbsp;</tt></span><a href="#%28part._.Categorizing_.Pizza_.Toppings%29" class="tocsubseclink" data-pltdoc="x">Categorizing Pizza Toppings</a></td></tr><tr><td><span class="tocsublinknumber">1.1<tt>&nbsp;</tt></span><a href="#%28part._.Operations__.Filter__.Member__.Distinct%29" class="tocsubseclink" data-pltdoc="x">Operations:<span class="mywbr"> &nbsp;</span> Filter, Member, Distinct</a></td></tr><tr><td><span class="tocsublinknumber">1.2<tt>&nbsp;</tt></span><a href="#%28part._.Operations_.Recap%29" class="tocsubseclink" data-pltdoc="x">Operations Recap</a></td></tr><tr><td><span class="tocsublinknumber">1.3<tt>&nbsp;</tt></span><a href="#%28part._.Map%29" class="tocsubseclink" data-pltdoc="x">Map</a></td></tr><tr><td><span class="tocsublinknumber">1.4<tt>&nbsp;</tt></span><a href="#%28part._.An_.Aside__.Tables_versus_.Lists%29" class="tocsubseclink" data-pltdoc="x">An Aside:<span class="mywbr"> &nbsp;</span> Tables versus Lists</a></td></tr><tr><td><span class="tocsublinknumber">2<tt>&nbsp;</tt></span><a href="#%28part._.Combining_.Map_and_.Filter%29" class="tocsubseclink" data-pltdoc="x">Combining Map and Filter</a></td></tr><tr><td><span class="tocsublinknumber">3<tt>&nbsp;</tt></span><a href="#%28part._.Summary_of_.List_.Operations%29" class="tocsubseclink" data-pltdoc="x">Summary of List Operations</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><h2><a name="(part._.Class_summary__.Operations_on_.Lists)"></a>Class summary: Operations on Lists</h2><p>Copyright (c) 2017 Kathi Fisler</p><p>Last class, we had our first introduction to lists, a way to group
together a collection of items (such as a collection of names, grades,
dates, images, etc). We saw how to create lists by hand (using
<span class="stt">[list: ...]</span>) and how to extract a list from the column of a
table (using <span class="stt">.get-column(colname)</span>).</p><p>Today, we cover some of the (many) operations on lists.  There&rsquo;s a
full list of the operations in the <a href="https://www.pyret.org/docs/latest/lists.html">Pyret lists
documentation</a>; we&rsquo;ll look at just a handful of them today.</p><p>We&rsquo;ll step away from tables and work with lists on their own for now.</p><h3>1<tt>&nbsp;</tt><a name="(part._.Categorizing_.Pizza_.Toppings)"></a>Categorizing Pizza Toppings</h3><p>Imagine that you are running a pizzeria and need to track different
categories of pizza toppings. Let&rsquo;s do that by setting up the
following lists:</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">meats = [list: "sausage", "pepperoni", "chicken", "shrimp"]</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">veggies = [list: "spinach", "peppers", "onion"]</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">unusual = [list: "egg", "pickle"]</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">premium = [list: "pickle", "shrimp"]</span></p></td></tr></table></p><p>What do we notice about lists from these examples?  Lists can have any
number of items. The items within a list are written as separated by
commas.</p><h4>1.1<tt>&nbsp;</tt><a name="(part._.Operations__.Filter__.Member__.Distinct)"></a>Operations: Filter, Member, Distinct</h4><p>The staff at your office have to vote on which toppings to get as part
of the weekly pizza lunch. You have a list of all the votes that
people have cast.</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">topping-votes =</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">[list: "peppers", "pepperoni", "onion", "onion", "onion"]</span></p></td></tr></table></p><p>Here are various expressions that show the list operations of
<span class="stt">distinct</span>, <span class="stt">member</span>, and <span class="stt">filter</span>. We introduced
<span class="stt">L.member</span> and <span class="stt">L.distinct</span> in the last lecture.
<span class="stt">L.filter</span> is analogous to the <span class="stt">filter-by</span> operation on
tables: filter takes a function that determines whether to keep
elements from the list in the output list.</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"># Which different veggies were ordered?</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">unique-veggies =</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">L.distinct(</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">L.filter(lam(t): L.member(veggies, t) end, topping-votes))</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"># What toppings to include on a vegetarian pizza? Leave off the meats</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">veg-friendly =</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">L.filter(lam(t): not(L.member(meats, t)) end,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">topping-votes)</span></p></td></tr></table></p><p>If you weren&rsquo;t sure how to start on something like "which different
veggies were ordered", you can start by writing out the tasks:</p><ol><li><p>Create a function that determines whether a string is in the
veggie list</p></li><li><p>Filter the veggies out of the topping-votes list</p></li><li><p>Remove duplicates from the list of veggies</p></li></ol><p>Each of these tasks is a separate expression in the code: the
<span class="stt">lam(t): L.member ...</span> is the function, L.filter extracts the
veggies, and L.distinct removes the duplicates.</p><h4>1.2<tt>&nbsp;</tt><a name="(part._.Operations_.Recap)"></a>Operations Recap</h4><p>What operations do we have so far?</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span style="font-weight: bold">Operation</span></p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p><span style="font-weight: bold">Types and Notes</span></p></td></tr><tr><td><p>L.member</p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p>List, item -&gt; Boolean</p></td></tr><tr><td><p></p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p>Indicates whether item in the list</p></td></tr><tr><td><p>L.distinct</p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p>List -&gt; List</p></td></tr><tr><td><p></p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p>Returns the unique values from input list</p></td></tr><tr><td><p>L.filter</p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p>(elt -&gt; Boolean), List -&gt; List</p></td></tr><tr><td><p></p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p>Returns list of items from input list
   on which function returns true (in same order as in input list)</p></td></tr></table></p><h4>1.3<tt>&nbsp;</tt><a name="(part._.Map)"></a>Map</h4><p>Now let&rsquo;s try another problem &ndash; it&rsquo;s vegetarian-awareness week, and
we want to replace all the meats in the list with tofu.</p><p>Let&rsquo;s think about what the input and output of this computation should
be.  We are starting with</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">[list: "peppers", "pepperoni", "onion", "onion", "onion"]</span></p></td></tr></table></p><p>which should become</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">[list: "peppers", "tofu", "onion", "onion", "onion"]</span></p></td></tr></table></p><p>Note there is exactly one item in the output list for each item in the
input list.</p><p>Which of our existing list operations can we use for this?  We need
something that produces a list, and some of the items are different
than in the input list.  None of the operations we have so far achieve
this, so we need something else.</p><p>What we need is an operation called <span class="stt">L.map</span>, which is similar to
transform-column or build-column from tables &ndash; L.map produces a list
with one item corresponding to each item in the given list, in the
same order.</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"># Make all ingredients vegetarian by replacing meat with tofu</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">fun replace-if-meat(str :: String) -&gt; String:</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">doc: "If string is a meat, return tofu, else return the string"</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">if L.member(meats, str):</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">"tofu"</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">else:</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">str</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">end</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">end</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">vegetarian-delight = L.map(replace-if-meat, topping-votes)</span></p></td></tr></table></p><h4>1.4<tt>&nbsp;</tt><a name="(part._.An_.Aside__.Tables_versus_.Lists)"></a>An Aside: Tables versus Lists</h4><p>It would seem we could have just as well put our topping information
in a table rather than all of these lists.  For example:</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span style="font-weight: bold">topping</span></p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p><span style="font-weight: bold">meat</span></p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p><span style="font-weight: bold">veggie</span></p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p><span style="font-weight: bold">unusual</span></p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p><span style="font-weight: bold">...</span></p></td></tr><tr><td><p>sausage</p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p>X</p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p></p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p></p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p></p></td></tr><tr><td><p>egg</p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p></p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p></p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p>X</p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p></p></td></tr><tr><td><p>pepperoni</p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p>X</p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p></p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p></p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p></p></td></tr><tr><td><p>spinach</p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p></p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p>X</p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p></p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p></p></td></tr><tr><td><p>...</p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p>...</p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p>...</p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p>...</p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p>...</p></td></tr></table></p><p>Stop and discuss &ndash; what are the tradeoffs between one table and our
multiple-lists approach?</p><p>Here are some observations on this:</p><ul><li><p>The table makes it easier to see which items are in multiple
categories</p></li><li><p>The table would let us make plots and charts using the
operations we know in Pyret</p></li><li><p>The lists are easier to write and modify</p></li><li><p>The tables could become sparse if we add more categories and
ingredients</p></li><li><p>For our L.filter operations, we can use L.member to look for
toppings in specific lists. With the tables, we&rsquo;d have to keep
filtering over the rows to find the meats/veggies/etc, extracting the
names, and comparing data. This feels much more complicated (and maybe
more expensive time-wise) than using L.member.</p></li></ul><p>Whether you use tables or lists depends on the data you have and how
you plan to use it.  For the programs we&rsquo;ve written today, the lists
were sufficient and lightweight, so they were the better choice.
Other programs might have benefitted from the table-shaped data. This
is our first real example of starting to consider choices in how we
represent information when designing programs.</p><h3>2<tt>&nbsp;</tt><a name="(part._.Combining_.Map_and_.Filter)"></a>Combining Map and Filter</h3><p>Here&rsquo;s one last example.</p><p>For tweeting and texting, people want to reduce the number of
characters they have to type. For example, instead of writing "are you
home?", they might write "R U home?".</p><p>This feels like a problem for L.map &ndash; we want to convert each string
in the original message to a shortened string.</p><p>Here&rsquo;s a function that shortens common strings:</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">fun shorten(w :: String) -&gt; String:</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">string-replace(</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">string-replace(</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">string-replace(w, "for", "4"),</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">"you", "U"),</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">"are", "R")</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">end</span></p></td></tr></table></p><p>How can we shorten all of the words in a message? Let&rsquo;s assume we have
a list of all the words.  Then we can use L.map.</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">msg-words = [list: "unfortunately", "you", "are", "late"]</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">msg-trim = L.map(shorten, msg-words)</span></p></td></tr></table></p><p>What if we want to find all of the words that are still long after
shortening?  We combine <span class="stt">map</span> and <span class="stt">filter</span>:</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">msg-words = [list: "unfortunately", "you", "are", "late"]</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">msg-trim =</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">L.filter(lam(w): string-length(w) &gt; 4 end,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">L.map(shorten, msg-words))</span></p></td></tr></table></p><h3>3<tt>&nbsp;</tt><a name="(part._.Summary_of_.List_.Operations)"></a>Summary of List Operations</h3><p>Let&rsquo;s extend our table of list operations to include map.  We&rsquo;ll also
add L.length, which is useful for getting the size of a list.</p><p>In the types, the notation <span class="stt">List&lt;type&gt;</span> means a list whose
elements are of the named type. When the type isn&rsquo;t fixed, we use
generic names like <span class="stt">item</span> and <span class="stt">elt</span> to show the relationship
between the types of the lists and the types of the functions used to
produce them.</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span style="font-weight: bold">Operation</span></p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p><span style="font-weight: bold">Types and Notes</span></p></td></tr><tr><td><p>L.member</p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p>List, item -&gt; Boolean</p></td></tr><tr><td><p></p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p>Indicates whether item in the list</p></td></tr><tr><td><p>L.distinct</p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p>List -&gt; List</p></td></tr><tr><td><p></p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p>Returns the unique values from input list</p></td></tr><tr><td><p>L.filter</p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p>(elt -&gt; Boolean), List&lt;elt&gt; -&gt; List&lt;elt&gt;</p></td></tr><tr><td><p></p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p>Returns list of items from input list
   on which function returns true (in same order as in input list)</p></td></tr><tr><td><p>L.map</p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p>(elt -&gt; item), List&lt;elt&gt; -&gt; List&lt;item&gt;</p></td></tr><tr><td><p></p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p>Returns result of calling function on each element of
   given list, in order</p></td></tr><tr><td><p>L.length</p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p>List -&gt; Number</p></td></tr><tr><td><p></p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p>Returns length of the list</p></td></tr></table></p></div></div><div id="contextindicator">&nbsp;</div></body></html>