<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>Class summary: How Hashtables Work</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="scribble-style.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9658;</a></td><td></td><td><a href="" class="tocviewselflink" data-pltdoc="x">Class summary:<span class="mywbr"> &nbsp;</span> How Hashtables Work</a></td></tr></table></div><div class="tocviewsublistonly" style="display: none;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="#%28part._.Hash_.Functions_and_.Hash_.Codes%29" class="tocviewlink" data-pltdoc="x">Hash Functions and Hash Codes</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="#%28part._.What_if_we_need_to_add_keys_to_the_hashtable_later_%29" class="tocviewlink" data-pltdoc="x">What if we need to add keys to the hashtable later?</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="#%28part._.Datatype_as_keys%29" class="tocviewlink" data-pltdoc="x">Datatype as keys</a></td></tr></table></div></div></div><div class="tocsub"><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber"></span><a href="#%28part._.Class_summary__.How_.Hashtables_.Work%29" class="tocsubseclink" data-pltdoc="x">Class summary:<span class="mywbr"> &nbsp;</span> How Hashtables Work</a></td></tr><tr><td><span class="tocsublinknumber">1<tt>&nbsp;</tt></span><a href="#%28part._.Hash_.Functions_and_.Hash_.Codes%29" class="tocsubseclink" data-pltdoc="x">Hash Functions and Hash Codes</a></td></tr><tr><td><span class="tocsublinknumber">2<tt>&nbsp;</tt></span><a href="#%28part._.What_if_we_need_to_add_keys_to_the_hashtable_later_%29" class="tocsubseclink" data-pltdoc="x">What if we need to add keys to the hashtable later?</a></td></tr><tr><td><span class="tocsublinknumber">3<tt>&nbsp;</tt></span><a href="#%28part._.Datatype_as_keys%29" class="tocsubseclink" data-pltdoc="x">Datatype as keys</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><h2><a name="(part._.Class_summary__.How_.Hashtables_.Work)"></a>Class summary: How Hashtables Work</h2><p>Copyright (c) 2017 Kathi Fisler</p><p>Now that you have a sense of how to program with hashtables, let&rsquo;s go
under the hood and see how they are able to do lookup in constant
time.</p><p>When we first started hashtables, we discussed this idea that if we
know where each item is in memory relative to the hashtable itself, we
can compute the location of an item in constant time.  The idea was
roughly along the following lines:</p><p>Assume that we have a block of 5 consecutively-numbered dorm rooms
(singles!) and we want to track which student has been assigned to
each room.  We might write this example as follows:</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">rooms = {1: "Heila",</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">2: "Eli",</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">3: "Josh",</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">4: "Nam",</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">5: "Julia"</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">}</span></p></td></tr></table></p><p>We could imaging putting each key/value in a separate memory location,
in order, such that we can use the keys to find the locations.</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">Prog Dictionary</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">Memory</span></p></td></tr><tr><td><p><span class="stt">-----------------------------------------------------------------------</span></p></td></tr><tr><td><p><span class="stt">rooms --&gt; loc 1001</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">loc 1001 --&gt; {loc 1002, loc 1003, ... loc 1006}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">loc 1002 --&gt; "Heila"</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">loc 1003 --&gt; "Eli"</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">loc 1004 --&gt; "Josh"</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">loc 1005 --&gt; "Nam"</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">loc 1006 --&gt; "Julia"</span></p></td></tr></table></p><p>Now, assuming we want to know who is in room 3.  We would write</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">rooms[3]</span></p></td></tr></table></p><p>and Python could get to location 1004 (where the value for key 3 is)
by looking up the address of <span class="stt">rooms</span> (getting loc 1001) and adding 3
to get loc 1004.</p><p>This is a fine intuition, but it doesn&rsquo;t generalize to keys that
aren&rsquo;t consecutive numbers. The picture for hashtables is bit more
subtle.</p><h3>1<tt>&nbsp;</tt><a name="(part._.Hash_.Functions_and_.Hash_.Codes)"></a>Hash Functions and Hash Codes</h3><p>What actually happens is summarized by the following picture:</p><p><img src="hashtable-fig.png" alt="" width="413" height="248"/></p><p>That box in the middle is called a <span style="font-style: italic">hash function</span>. The hash
function takes keys as inputs and produces offsets or indices into the
hashtable as outputs (these outputs are called <span style="font-style: italic">hashcodes</span>). The
hashcodes will be used both to store the value and to retrieve values
associated with keys.</p><p>As another example, go back to our hashtable mapping from
classrooms to seating capacity from last lecture:</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"># map course codes to seating capacity</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">seats = {"CIT368": 63,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">"BERT130": 200,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">"FRDMN101": 48</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">}</span></p></td></tr></table></p><p>Assume <span style="font-style: italic">h</span> is our hash function and that <span class="stt">seats</span> is at
loc 1007.  If you write</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">seats["BERT130"]</span></p></td></tr></table></p><p>then under the hood, the language gets the value from</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">loc 1007 + h("BERT130")</span></p></td></tr></table></p><p>As long as the hash function maps every key to a unique offset within
the size of the hashtable, all of this works fine.</p><p>Who defines the hash function? The programming language does this for
you automatically, based on the type of the keys. Roughly, Python maps
each type (or component thereof) to a prime number, multiplies the
parts together and uses modulo to make the number fit in the size of
the hashtable.  As a programmer, you never see the hash function or
the mapping. It all happens under the hood. Hash functions depend on
a fair bit of mathematics that are beyond what we will cover in this
course. But that is what&rsquo;s going on.</p><h3>2<tt>&nbsp;</tt><a name="(part._.What_if_we_need_to_add_keys_to_the_hashtable_later_)"></a>What if we need to add keys to the hashtable later?</h3><p>This approach of adding offsets depends on all of the values being in
consecutive locations in memory. But what if you set up a hashtable,
then need to add key-value pairs later? You won&rsquo;t have consecutive
locations anymore.</p><p>There are several answers to this. First, hashtables actually set
aside extra locations up front (the default differs across
languages). When you run out of that room, different languages take
different approaches: small hashtables might just be resized into a
new memory location. Larger hashtables get extended in other ways. As
a programmer, this is again an issue you don&rsquo;t have to think about.</p><p>For those moving onto CS18, we will implement hashtables and their
extension mechanisms in detail as part of the course.</p><h3>3<tt>&nbsp;</tt><a name="(part._.Datatype_as_keys)"></a>Datatype as keys</h3><p>Hashtables allow any type to serve as either keys or values.  Imagine
that an airline wants to use Flights as keys to look up lists of
passengers:</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">from dataclasses import dataclass</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">@dataclass</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">class Flight:</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">num: int</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">frm: str</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">to: str</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">roster = {Flight(206, "PVD", "DEN"): ["Kathi", "Eli"],</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">Flight(315, "PVD", "NYC"): ["Heila"],</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">Flight(420, "PVD", "CHI"): ["Josh"]</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">}</span></p></td></tr></table></p><p>If we try to run this, Python reports "unhashable type:
Flight". What&rsquo;s the problem?</p><p>When dataclasses (or other complex data) are used as keys, Python
creates the hash function using the values in the components of the
class. For example, for <span class="stt">Flight(206, "PVD", "DEN")</span>, the hashcode
will depend on the specific values 206, "PVD", and "DEN".</p><p>For a hashtable to work, however, the same item in memory must
always map to the same hashcode (otherwise, Python will look in a
different location to retrieve the value). What if we update
a component of the class though (such as the balance in an account)?
The next time the hash function gets called (say to lookup the value),
the component values are different, so the item will hash to a
different memory location. This means you can&rsquo;t actually get back to
the original value stored for the key!</p><p>To avoid this problem, follow a straightforward rule: <span style="font-style: italic">don&rsquo;t use
classes that you plan to mutate/update as hashtable keys</span>. This is a
reasonable restriction for flights (changing any component would mean
creating a new flight). It isn&rsquo;t a reasonable restriction for
Accounts.</p><p>What remains is to tell Python that we don&rsquo;t plan to modify the values
of the components of Flights.  We add an annotation to the dataclass
to convey this:</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">@dataclass(frozen=True)</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">class Flight:</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">num: int</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">frm: str</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">to: str</span></p></td></tr></table></p><p>The <span class="stt">frozen</span> annotation says "the components of this class cannot
be changed". If you try to assign to a component of a frozen class
such as Flight, Python will produce an error.</p><p>In practice, there are ways to use values with changing components as
keys, but they are more advanced that we want to cover this
semester. What we&rsquo;ve shown should suffice for whatever practical
programming most of you will do coming out of 111. We will show the
more advanced material in CS18.  If you want to read details for
yourself, look up <span class="stt">_hash_</span> methods in Python (though be aware that
this relies on some other Python material that we haven&rsquo;t covered this
semester).</p></div></div><div id="contextindicator">&nbsp;</div></body></html>